require 'builder'

module Shapewear
  module DSL
    def self.included(receiver)
      receiver.extend(ClassMethods)
    end

    #noinspection RubyArgCount,RubyResolve
    module ClassMethods

      # reference: http://www.w3.org/TR/wsdl
      def to_wsdl
        tns = "http://shapewear.elementarsistemas.com.br/auto/#{self.name}.wsdl"
        xsd = "http://shapewear.elementarsistemas.com.br/auto/#{self.name}.xsd"

        xm = Builder::XmlMarkup.new

        xm.instruct!
        xm.definitions :name => self.name, 'targetNamespace' => tns,
                       'xmlns' => 'http://schemas.xmlsoap.org/wsdl/',
                       'xmlns:soap' => 'http://schemas.xmlsoap.org/wsdl/soap/',
                       'xmlns:xsd1' => xsd, 'tns' => tns do |xdef|

          xdef.types do |xtypes|
            xtypes.schema 'xmlns' => 'http://www.w3.org/2000/10/XMLSchema', 'targetNamespace' => xsd do |xschema|

              # define elements for each defined method
              instance_methods(false).each do |m|
                build_type_elements_for_method(m, xschema)
              end
            end
          end

          instance_methods(false).each do |m|
            xdef.message :name => "#{m.camelize}Input" do |xmsg|
              xmsg.part :name => :body, :element => "xsd1:#{m.camelize}Request"
            end unless instance_method(m).arity == 0
            xdef.message :name => "#{m.camelize}Output" do |xmsg|
              xmsg.part :name => :body, :element => "xsd1:#{m.camelize}"
            end
          end

          xdef.portType :name => "#{self.name}PortType" do |xpt|
            instance_methods(false).each do |m|
              xpt.operation :name => m.camelize do |xop|
                xop.input :message => "tns:#{m.camelize}Input" unless instance_method(m).arity == 0
                xop.output :message => "tns:#{m.camelize}Output"
              end
            end
          end

          xdef.binding :name => "#{self.name}Binding", :type => "tns:#{self.name}PortType" do |xbind|
            xbind.tag! 'soap:binding', :style => 'document', :transport => 'http://schemas.xmlsoap.org/soap/http'
            instance_methods(false).each do |m|
              xbind.operation :name => m.camelize do |xop|
                xbind.tag! 'soap:operation', :soapAction => "http://shapewear.elementarsistemas.com.br/auto/op/#{m.camelize}"
                xbind.input { |xin| xin.tag! 'soap:body', :use => 'literal' } unless instance_method(m).arity == 0
                xbind.output { |xin| xin.tag! 'soap:body', :use => 'literal' }
              end
            end
          end

          xdef.service :name => self.name do |xsrv|
            xsrv.documentation "WSDL auto-generated by shapewear."
            xsrv.port :name => "#{self.name}Port", :binding => "#{self.name}Binding" do |xport|
              xport.tag! 'soap:address', :location => "..." # TODO: let the developer configure
            end
          end
        end
      end

      def build_type_elements_for_method(m, xschema)
        # element for method arguments
        um = instance_method(m)

        if um.arity > 0
          xschema.element :name => "#{m.camelize}Request" do |xreq|
            xreq.complexType do |xct|
              xct.all do |xall|
                if um.respond_to?(:parameters)
                  # with Ruby 1.9, we can create the parameters with the correct names
                  params = um.parameters.select { |p| p.first == :in }.map &:first
                else
                  params = (0..um.arity).map { |i| "arg#{i}" }
                end

                params.each do |p|
                  xall.element :name => p, :type => 'xsd:string' # TODO: there must be a better way
                end
              end
            end
          end
        end

        # element for method result
        xschema.element :name => "#{m.camelize}" do |xreq|
          xreq.complexType do |xct|
            xct.all do |xall|
              xall.element :name => 'result', :type => 'xsd:string'
            end
          end
        end
      end
    end
  end
end
